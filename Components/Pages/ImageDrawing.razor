@page "/image-drawing"
@rendermode InteractiveServer
@inject IJSRuntime JS

<PageTitle>Image Drawing</PageTitle>

<div class="page-container">
    <div class="sidebar-left">
        <h3 class="sidebar-title">Image Viewer</h3>
        
        <div class="control-section">
            <label class="control-label">Image Path</label>
            <input type="text" class="form-control" @bind="imagePath" placeholder="sample-image.jpg" />
            <button class="btn btn-success btn-block" @onclick="LoadImage">üìÇ Load Image</button>
        </div>

        <div class="control-section">
            <label class="control-label">Zoom Controls</label>
            <div class="zoom-buttons">
                <button class="btn btn-secondary btn-block" @onclick="ZoomIn" title="Zoom In">üîç+ Zoom In</button>
                <button class="btn btn-secondary btn-block" @onclick="ZoomOut" title="Zoom Out">üîç- Zoom Out</button>
                <button class="btn btn-secondary btn-block" @onclick="ResetZoom" title="Reset Zoom">‚Ü∫ Reset</button>
            </div>
            <div class="zoom-level">Zoom: @($"{currentZoom:F1}x")</div>
        </div>

        <div class="control-section">
            <label class="control-label">Drawing Tools</label>
            <button class="btn btn-primary btn-block" @onclick="ClearRectangles">üóëÔ∏è Clear Rectangles</button>
        </div>

        <div class="info-section">
            <p class="info-text">
                <strong>Controls:</strong><br/>
                üñ±Ô∏è Scroll to zoom<br/>
                Middle Mouse to pan<br/>
                Shift+Drag to pan<br/>
                Click+Drag to draw
            </p>
        </div>

        @if (rectangles.Any())
        {
            <div class="rectangles-list">
                <h4>Rectangles (@rectangles.Count)</h4>
                <ul>
                    @foreach (var (rect, index) in rectangles.Select((r, i) => (r, i)))
                    {
                        <li>@(index + 1): X=@rect.X, Y=@rect.Y, W=@rect.Width, H=@rect.Height</li>
                    }
                </ul>
            </div>
        }
    </div>

    <div class="canvas-area">
        <canvas @ref="canvasElement" 
                id="drawingCanvas" 
                width="1200" 
                height="1600"
                @onmousedown="OnMouseDown"
                @onmousemove="OnMouseMove"
                @onmouseup="OnMouseUp"
                @onmouseleave="OnMouseLeave"
                tabindex="0">
        </canvas>
    </div>
</div>

@code {
    private ElementReference canvasElement;
    private bool isDrawing = false;
    private bool isPanning = false;
    private Point? startPoint;
    private List<Rectangle> rectangles = new();
    private Rectangle? currentRectangle;
    private string imagePath = "sample-image.jpg";
    private double currentZoom = 1.0;
    private System.Threading.Timer? zoomUpdateTimer;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JS.InvokeVoidAsync("initializeCanvas", canvasElement);
            
            // Start timer to update zoom level display
            zoomUpdateTimer = new System.Threading.Timer(async _ =>
            {
                try
                {
                    var zoom = await JS.InvokeAsync<double>("getZoomLevel");
                    if (Math.Abs(currentZoom - zoom) > 0.01)
                    {
                        currentZoom = zoom;
                        await InvokeAsync(StateHasChanged);
                    }
                }
                catch { }
            }, null, TimeSpan.FromMilliseconds(100), TimeSpan.FromMilliseconds(100));
        }
    }

    public void Dispose()
    {
        zoomUpdateTimer?.Dispose();
    }

    private async Task LoadImage()
    {
        if (!string.IsNullOrWhiteSpace(imagePath))
        {
            rectangles.Clear();
            currentRectangle = null;
            await JS.InvokeVoidAsync("loadImageByPath", canvasElement, imagePath);
        }
    }

    private async Task OnMouseDown(MouseEventArgs e)
    {
        // Middle mouse button or Space key + left mouse button for panning
        if (e.Button == 1 || (e.Button == 0 && e.ShiftKey))
        {
            isPanning = true;
            await JS.InvokeVoidAsync("startPan", e.ClientX, e.ClientY);
            return;
        }
        
        // Left mouse button for drawing rectangles
        if (e.Button == 0 && !e.ShiftKey)
        {
            isDrawing = true;
            var coords = await JS.InvokeAsync<CanvasCoordinates>("screenToCanvasCoordinates", canvasElement, e.ClientX, e.ClientY);
            startPoint = new Point
            {
                X = (int)coords.X,
                Y = (int)coords.Y
            };
            currentRectangle = new Rectangle { X = startPoint.X, Y = startPoint.Y, Width = 0, Height = 0 };
        }
    }

    private async Task OnMouseMove(MouseEventArgs e)
    {
        if (isPanning)
        {
            await JS.InvokeAsync<bool>("updatePan", canvasElement, e.ClientX, e.ClientY);
            return;
        }
        
        if (isDrawing && currentRectangle != null && startPoint != null)
        {
            var coords = await JS.InvokeAsync<CanvasCoordinates>("screenToCanvasCoordinates", canvasElement, e.ClientX, e.ClientY);
            var currentX = (int)coords.X;
            var currentY = (int)coords.Y;

            currentRectangle.Width = currentX - startPoint.X;
            currentRectangle.Height = currentY - startPoint.Y;

            await DrawAll();
        }
    }

    private async Task OnMouseUp(MouseEventArgs e)
    {
        if (isPanning)
        {
            isPanning = false;
            await JS.InvokeVoidAsync("endPan");
            return;
        }
        
        if (isDrawing && currentRectangle != null)
        {
            rectangles.Add(new Rectangle
            {
                X = currentRectangle.X,
                Y = currentRectangle.Y,
                Width = currentRectangle.Width,
                Height = currentRectangle.Height
            });
            currentRectangle = null;
            isDrawing = false;
            await DrawAll();
        }
    }

    private async Task OnMouseLeave(MouseEventArgs e)
    {
        if (isPanning)
        {
            isPanning = false;
            await JS.InvokeVoidAsync("endPan");
        }
    }

    private async Task DrawAll()
    {
        await JS.InvokeVoidAsync("redrawCanvas", canvasElement, rectangles, currentRectangle);
    }

    private async Task ClearRectangles()
    {
        rectangles.Clear();
        currentRectangle = null;
        await DrawAll();
    }

    private async Task ZoomIn()
    {
        await JS.InvokeVoidAsync("zoomIn", canvasElement);
    }

    private async Task ZoomOut()
    {
        await JS.InvokeVoidAsync("zoomOut", canvasElement);
    }

    private async Task ResetZoom()
    {
        await JS.InvokeVoidAsync("resetZoom", canvasElement);
    }

    public class Point
    {
        public int X { get; set; }
        public int Y { get; set; }
    }

    public class Rectangle
    {
        public int X { get; set; }
        public int Y { get; set; }
        public int Width { get; set; }
        public int Height { get; set; }
    }

    public class BoundingRect
    {
        public double Left { get; set; }
        public double Top { get; set; }
    }

    public class CanvasCoordinates
    {
        public double X { get; set; }
        public double Y { get; set; }
    }
}
